https://excalidraw.com/#room=682b2c5c9c5835bb3fd2,5KFxse5OeORDs3z__RSN_A

https://prod.liveshare.vsengsaas.visualstudio.com/join?94B3E8A1C9D934695EEEAF50B59D1A369F29

ARREGLAR:

- EN GENERAL TENER EN CUENTA CODIGOS DE ERROR Y MENSAJES

/****************** CD *****************\
âœ… cd -> cuando no tenemos HOME, al hacer cd "~" debe irse al HOME. Si HOME ya existe, lo agarra. Si no, coge el predeterminado.

/**************** EXPORT ***************\
â“ export GHOST=123 | env | grep GHOST -> parece no crear la variable
Este caso en concreto parecÃ­a que funcionaba al principio y ahora no (BASH)

/************* REDIRECTIONS ************\
âœ… ls >"./outfiles/outfile""1""2""3""4""5"
/************* UNSET ************\
unset 1231 -> BASH: unset `1231': not a valid identifier

Tipos de errores para exit_status
- 0: Ã‰xito
- 1: Error general
- 2: Error de sintaxis o uso incorrecto
- 126: El comando existe pero no es ejecutable
- 127: El comando no fue encontrado
- 128+n: El programa terminÃ³ debido a una seÃ±al n


ğŸ“’ __________ TODO LIST __________ ğŸ“’

-	 [âœ…] Mostrar una entrada mientras esperas comando.
-	 [âœ…] Tener un historial funcional.
-	 [âœ…] Buscar y ejecutar basado en la variable PATH.
-	 [âœ…] Ejecutar mediante ruta relativa/absoluta (incluye minishell).
-  	 [ â“] Evitar el uso mÃ¡s de 1 variable global para la recepciÃ³n de una seÃ±al.
-	 [âœ…] No interpretar comillas sin cerrar, \ o ;.
-	 [âœ…] Gestionar que ' interprete metacaracteres dentro de la secuencia entre ""
-	 [âœ…] Gestionar que " interprete metacaracteres exceptuando el $.
4	 [  ] ImplementaciÃ³n de redirecciones (<, >, <<, >>).
3	 [âœ…] ImplementaciÃ³n de pipes (|).
		[âœ…] Redireciona pero acaba el proceso.
		[âœ…] No acepta argumentos entre comillas, hay que hacer clean_input.
-	 [âœ…] ExpansiÃ³n de variables de entorno.
-	 [âœ…] GestiÃ³n de $?.
2    [âœ…] GestiÃ³n de Ctrl-C, Ctrl-D y Ctrl-\, deben funcionar como bash.
	2.1	[âœ…] Ctrl-C (Imprime salto de linea), Ctrl-D (Termina SHELL) y Ctrl-\ (No hace nada).
	 [âœ…] Built-ins: echo (-n), cd (Rutas relativas/absolutas), pwd, export, unset, env y exit.
		[âœ…] Rutas absolutas (cd ~ funciona con /)
		[âœ…] Export revisarlo para sobreescribir variables (Planteamiento comentado en export.c)

ğŸ“’ __________ NORMINETTE LIST __________ ğŸ“’

 ğŸ“ [â“] src
	-	 [âœ…] minishell.c
	-	 [âœ…] update_minishell.c
	-	 [  ] exec.c
	-	 [  ] path_utils.c
	-	 [  ] path.c
	-	 [  ] signals.c
	-	 [  ] variable_expansion.c
	 ğŸ“ [â“] parse
		-	 [â“] input_utils.c (muchas funciones)

-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos

âœ… ""
âœ… ''
âœ… echo $
âœ… exit 3456 -> deberia de salir con arg[1] % 256
âœ… exit hola -> deberÃ­a de salirse con el codigo 2 al hacer echo $?
âœ… revisar funcionamiento de "wc < wc << pejjo"
âœ… ls || wc
âœ… wc < hola.txt < (redireccion abierta hay que manejarlo)
âœ… NO SE SI MANEJAR -> cd - , se va al pwd anterior, y si lo vuelves a usar vuelve al anterior
âœ… cd | exit -> NO deberia de salirse
âœ…"ls -> mensaje de quotes abiertas
âœ… export a=, deberÃ­a de exportar a=""
âœ… export a, se duplica. Solo manejamos con =, pero sin = se acaba duplicando -> hemos hecho que si exporta "casa" se exporte como "casa=", valido?
âœ… export cuando haces por ej; HOME+=perro serÃ­a como concatenarle perro
âœ… export debe aceptar varias variables (si falla una, las demas se deben hacer)
âœ… wc << EOF1 | grep hola << EOF2 -> actualmente wc sale a pantalla en lugar de la pipe
âœ… export jojo y luego export jojo+=jiji, en declare_matrix se duplica, deberÃ­a de existir solo jojo=jiji
âœ… LIMPIAR CD, hay que reformularlo mÃ¡s legible y con mÃ¡s sentido (variables, funciones, etc.)
âœ… cd -> cuando HOME no existe deberia dar "bash: cd: HOME not set"



ğŸ“ __________ GDB DEBUGGING GUIDE __________ ğŸ“

FORK DEBUGGING:
- Start GDB: `gdb -tui ./minishell`
- Follow child process after fork: `set follow-fork-mode child`
- Set up before running: `set detach-on-fork off`
- Set initial breakpoints: `b ft_pipe` `b execute_cmd`
- Run program: `r`
- List all forked processes: `info inferiors`
- Switch between processes: `inferior num`
- Analyze pipes: `p minishell->pipe_tools.pipes[0]`
- Check FDs: `shell ls -l /proc/$(pid)/fd`
- Switch process: `inferior 2` (child process)

USEFUL VARIABLES TO WATCH:
- Process info: `p getpid()`
- Fork result: `p fork_pid`
- Pipe FDs: `p minishell->pipe_tools.pipes[0].read_pipe` `p minishell->pipe_tools.pipes[0].write_pipe`



Lista de excepciones con echo + redirecciones:

âœ… [1] EJEMPLO: echo >hola
- BASH: Crea el archivo "hola" y lo deja vacÃ­o.
- MINISHELL: Crea el archivo "hola" y lo deja vacÃ­o.

âœ… [2] EJEMPLO: echo ">hola"
- BASH: Imprime ">hola" en la salida estÃ¡ndar.
- MINISHELL: No imprime nada.

âœ… [3] EJEMPLO: echo "hola >"
- BASH: Imprime "hola >" en la salida estÃ¡ndar.
- MINISHELL: Imprime "hola >" en la salida estÃ¡ndar.

âœ… [4] EJEMPLO: echo "hola >" > archivo
- BASH: Crea el archivo "archivo" y le introduce "hola >".
- MINISHELL: Crea el archivo "archivo" y le introduce "hola >".

âœ… [5] EJEMPLO: echo hola>
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

âœ… [6] EJEMPLO: echo |jeje
- BASH: bash: jeje: command not found
- MINISHELL: minishell: jeje: command not found

âœ… [7] EJEMPLO: echo "ho > la" | wc
- BASH: Devuelve 1 3 8, resultado de wc.
- MINISHELL: Devuelve 1 3 8, resultado de wc.

âœ… [8] EJEMPLO: echo hola < TODO.txt
- BASH: Imprime "hola" en la salida estÃ¡ndar.
- MINISHELL: Imprime "hola" en la salida estÃ¡ndar.

âœ… [9] EJEMPLO: echo hola << jeje
- BASH: Imprime "hola" en la salida estÃ¡ndar.
- MINISHELL: Imprime "hola" en la salida estÃ¡ndar.

âœ… [10] EJEMPLO: echo ">" (tambiÃ©n ">>", "<<" y "<")
- BASH: Imprime > en la salida estÃ¡ndar.
- MINISHELL: Imprime ">" en la salida estÃ¡ndar.

âœ… [11] EJEMPLO: echo "|"
- BASH: Imprime | en la salida estÃ¡ndar.
- MINISHELL: Imprime | en la salida estÃ¡ndar.

âœ… [12] EJEMPLO: echo <
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

âœ… [13] EJEMPLO: echo >
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

âœ… [14] EJEMPLO: echo |
- BASH: Abre un heredoc
- MINISHELL: minishell: syntax error cmd after pipe

/* ---------- TODO 22/05/2025 --------- */

âœ… 1.- Si se ejecuta minishell sin variables de entorno debe estar controlado -> if (!env || !*env)

âœ… 2.- Redir in debe redirigir el input independientemente de si estÃ¡ antes o despuÃ©s, si es el Ãºltimo debe hacerlo. Ejemplo: <archivo cat
âœ…| >
âœ…| <
âœ…| <<
âœ…| >>

âœ…3.- SHLVL debe aumentarse cuando ejecutas shell dentro de minishell
âœ… Hay que implementarlo, funciÃ³n hecha con condiciÃ³n, ver el sitio

âœ… 4.- ""''"" da segfault, """", ''''

âœ… 5.- Si una carpeta se llama ls, al hacer ls ls, debe ejecutar el comando dentro de la carpeta, eso quiere decir que el comando tiene prioridad frente al archivo que estÃ© en la ruta actual.

 touch cat
 chmod 755 cat
 cat file
Esto no hace cat del file, hay que asegurarse de que si el cmd no contiene "/" busque en el PATH

âœ… 6.- cat saliendose con ctrl +c deberia de dar 130 en el echo $?

âœ… 7.- cd algo, unset OLDPWD, cd - -> nos da segfault, debe escribir un mensaje que sea minishell: cd: OLDPWD not set
âœ… Â¿Se vuelve a setear OLDPWD al cambiar de directorio? SI

âœ… 8.- Cuando hace exit sin arg, usa el ultimo codigo de salida. Con arg numerico el modulo del argumento de 256
â“ Chequear el resto de codigos de salida para ver si salen correctos

âœ… 9.- < Makefile cat < popo debe redireccionar el archivo popo a cat, e imprime su contenido

âœ… 10.- << popo cat << lala | cat << lala2 -> Deberia ser popo, lala y luego lala2, pero no funciona
â“ Probamos a hacerlo el 26/05 e iba bien, rarete

âœ… ejecutarlo con ./leaks, es para ver fds abiertos y still reachables
â“ Aparentemente el unico still reachable es la estÃ¡tica de shell_prompt

âœ… Al cerrar pipes los inputs parecen haberse trastocado

REVISADO NÃšMERO FUNCIONES POR ARCHIVOS Y NORMINETTE

PROBLEMA CON EL INCLUDE EN TODOS LOS ARCHIVOS

/*------built-in-----*/

âœ… âœ… built (2)
âœ… âœ…ft_cd (4) 
	âœ… âœ…cd_utils (5)
âœ… âœ… echo (2)
âœ… âœ… env (1)
âœ… âœ… exit (3)
âœ… âœ… export (2)
	âœ… âœ…export_cases (5)
	âœ… âœ…export_declare (3)
	âœ… export_utils (5)
âœ… âœ… pwd (1)
âœ… âœ… unset (4)

/*--------MAIN--------*/

âœ… âœ… minishell_utils.c (3)
âœ… âœ… update_minishell (4)

/*------PARSE--------*/

âœ… âœ… input.c (3)
âœ… âœ… input_utils (4)
âœ… âœ… prompt.c (2)
âœ… âœ… is_redirection.c (4)
âœ… âœ… split.c (5) 
âœ… âœ… split_utils (5)
âœ… âœ… path_utils (3)
âœ… âœ… path (2)
âœ… âœ… QUOTE_UTILS (2)
âœ… âœ… expand_var (5)
âœ… âœ… expand_redir (4)

/*-------REDIRECTION_UTILS--------*/

âœ… âœ… fork_redir (3)
âœ… âœ… pipe_libft (1)
âœ… âœ… pipe_utils (3)
âœ… âœ… redir_cmd_cleaner (2)
âœ… âœ… fd_utils (5)

/*---------REDIRECTIONS-------------*/

âœ… âœ… redir_in (4)
âœ… âœ… redir_out (2)
âœ… âœ… redir_pipe (2)
âœ… âœ… redirect (3)
âœ… âœ… redirect_utils (3)

/*-----------VALIDATIONS------------*/

âœ… âœ… valid_cmd (2)
âœ… âœ… valid_env_char (1)
âœ… âœ… valid_rl_input (2)
âœ… âœ… valid_symbols (1)
âœ… âœ… valid_redir (5)


âœ… exec (4)
âœ… signals (2)
----

-------- FERNANDO -------

HEREDOC -> no se puede salir con CTRL + C, en bash SÃ se sale

âœ… CMD cat, cuando hacemos CTRL + C se sale sin el salto de lÃ­nea

âœ… Los syntax error deben dar el codigo de error correcto

-------- VÃCTOR -------

âœ… problema:	Cuando hay un error de sintaxis no se pone el codigo de salida
solucion:	Establecerlo en 2 o un valor diferente a 0
necesario:	No, pero no cuesta mucho hacerlo

âœ… problema:	Espacio muy grande en mensaje (ls >)
solucion:	Quitar el espacio. lol
necesario:	No

âœ… problema:	2 o mas tokens de redireccion juntos se tratan como input (< < cat o < < < cat)
solucion:	Si el input de una redireccion es un token de redireccion mostrar error de sintaxis
necesario:	No

BUILT-IN
--------

problema:	Cuando se esta en una carpeta invalida (borrada) deja de funcionar cd. (mkdir -p a/b/c), (cd a/b/c), (rm -rf ../../../a)
solucion:	No sabria decir, no me he puesto a ver el codigo, pero no es importante. Probablemente no estais ejecutando chdir
necesario:	No, son casos extremos. Aunque no creo que sea complicado de solucionar.
â“ Esto se controla haciendo un chdir al home predeterminado

SEÃ‘ALES
-------

repo guay: https://github.dev/zafraedu/minishell/tree/main/src

OJO!!!		Creo que no teneis una variable global para las seÃ±ales. Es necesaria para poder saber si se ha producido un SIGINT y cancelar la ejecucion (heredoc, etc.)

âœ… problema:	CTRL + \ (SIGQUIT) no se ignora
âœ… solucion:	Establecer SIGQUIT en SIG_IGN y al ejecutar un hijo, establecerlo en SIG_DFL
necesario:	Si, especificado en el subject

âœ… problema:	CTRL + C no pone el last status a 130 (128 + signal)
solucion:	En algun momento comprobar si la variable de las seÃ±ales es diferente de 0 y asignar 128 mas esa variable a las status (suponiendo que la variable sea el valor de la seÃ±al)
necesario:	Quizas, aunque si el evaluador no es muy cerrado, lo puede dejar pasar

problema:	CTRL + C se ejecuta en los hijos (cat y CTRL + C) y sale doble prompt
necesario:	Quizas, aunque si el evaluador no es muy cerrado, lo puede dejar pasar

problema:	CTRL + C no funciona en heredoc (<< a cat y CTRL + C) y cuando hay varios juntos hace cosas mas extraÃ±as aun ( << a cat << b <<c | <<a cat y CTRL + C)
necesario:	Si, especificado en el subject

âœ… problema:	Espacio muy grande en mensaje en el heredoc al hacer CTRL + D (<< a cat y CTRL + D)
solucion:	Quitar el espacio. lol
necesario:	No

âœ… problema:	Linea extra al hacer CTRL + C despues de un CTRL + D en un heredoc
solucion:	No sabria decir donde, es por cosas de seÃ±ales
necesario:	No, eso le ha pasado a mas gente y dudo que un evaluador lo tenga en cuenta

âœ… problema:	Al salir con CTRL + D no se sale con el ultimo codigo de salido
solucion:	Cuando readline devuelve NULL dependiendo de como se salga, hacer return (last_code) o exit(last_code)
necesario:	Quizas, no se si se dice explicitamente, pero no deberia ser dificil de implementar

âœ… LEAKS
-----

âœ… Al parecer en los hijos hay 2 FD que se quedan abiertos (aparte de los standars)
Pueden ser backups de STDIN y STDOUT si los haceis en el padre, ya que el hijo los hereda o
puede que sean otros. Se crean en minishell_store_fd() al parecer

âœ… Luego "leaks" tambien hay algunos. No son leaks, pero para 42 todo lo que no se libere se considera leak...
Y en el padre tambien hay algo de leak

kobayashi âœ /mnt/d/Programas/Mis Programas/42/Active/mini âœ¦ echo popo | echo popo

==81991== FILE DESCRIPTORS: 5 open (3 std) at exit.
==81991== Open file descriptor 4: /dev/pts/0
==81991==    at 0x49CB93B: dup (syscall-template.S:120)
==81991==    by 0x10DFF1: minishell_store_fd (fd_utils.c:43)
==81991==    by 0x10B13B: init_minishell (minishell_utils.c:18)
==81991==    by 0x10B5C0: main (minishell.c:31)
==81991==
==81991== Open file descriptor 3: /dev/pts/0
==81991==    at 0x49CB93B: dup (syscall-template.S:120)
==81991==    by 0x10DFE0: minishell_store_fd (fd_utils.c:42)
==81991==    by 0x10B13B: init_minishell (minishell_utils.c:18)
==81991==    by 0x10B5C0: main (minishell.c:31)
==81991==
==81991==



<< eof : no se queda ninguna abierta


<< eof | ls : se quedan abiertas las 5 y 6
/*

0: STDIN	3: COPIA DE STDIN	6: PIPE DE ESCRITURA CREADA EN HANDLE_REDIR
1: STDOUT	4: COPIA STDOUT
2: STDERR	5: PIPE DE LECTURA CREADA EN HANDLE REDIR


APUNTE DE PIPES:
STANDARD
0 - 1
COPIA STANDARD
3 - 4

1 PIPE CREADA
5 - 6

PADRE:
* Cierra 6

HIJO:
* Crea una temp_pipe: 7 - 8
* Cierra 3 - 4
* Cierra 5 - 6
* Cierra 7 - 8

*/


ls | << eof : se queda abierta la 5

/*
APUNTE DE PIPES:
STANDARD
0 - 1
COPIA STANDARD
3 - 4

1 PIPE CREADA
5 - 6

PADRE:
* Cierra 6
* Cierra 7 - 8

HIJO DE HEREDOC:
* Cierra 3 - 4
* Cierra 5 - 6
* Cierra 7 - 8

HIJO:
* Cierra 5 - 6


*/

cat << eof | ls | cat << eof2 (SALIR SIN CONTROL + C, HACERLO DE MANERA TRADICIONAL)

