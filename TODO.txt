https://excalidraw.com/#room=682b2c5c9c5835bb3fd2,5KFxse5OeORDs3z__RSN_A

https://prod.liveshare.vsengsaas.visualstudio.com/join?94B3E8A1C9D934695EEEAF50B59D1A369F29

ARREGLAR:

- EN GENERAL TENER EN CUENTA CODIGOS DE ERROR Y MENSAJES

/****************** CD *****************\
‚úÖ cd -> cuando no tenemos HOME, al hacer cd "~" debe irse al HOME. Si HOME ya existe, lo agarra. Si no, coge el predeterminado.

/**************** EXPORT ***************\
‚ùì export GHOST=123 | env | grep GHOST -> parece no crear la variable
Este caso en concreto parec√≠a que funcionaba al principio y ahora no (BASH)

/************* REDIRECTIONS ************\
‚úÖ ls >"./outfiles/outfile""1""2""3""4""5"
/************* UNSET ************\
unset 1231 -> BASH: unset `1231': not a valid identifier

Tipos de errores para exit_status
- 0: √âxito
- 1: Error general
- 2: Error de sintaxis o uso incorrecto
- 126: El comando existe pero no es ejecutable
- 127: El comando no fue encontrado
- 128+n: El programa termin√≥ debido a una se√±al n


üìí __________ TODO LIST __________ üìí

-	 [‚úÖ] Mostrar una entrada mientras esperas comando.
-	 [‚úÖ] Tener un historial funcional.
-	 [‚úÖ] Buscar y ejecutar basado en la variable PATH.
-	 [‚úÖ] Ejecutar mediante ruta relativa/absoluta (incluye minishell).
-  	 [ ‚ùì] Evitar el uso m√°s de 1 variable global para la recepci√≥n de una se√±al.
-	 [‚úÖ] No interpretar comillas sin cerrar, \ o ;.
-	 [‚úÖ] Gestionar que ' interprete metacaracteres dentro de la secuencia entre ""
-	 [‚úÖ] Gestionar que " interprete metacaracteres exceptuando el $.
4	 [  ] Implementaci√≥n de redirecciones (<, >, <<, >>).
3	 [‚úÖ] Implementaci√≥n de pipes (|).
		[‚úÖ] Redireciona pero acaba el proceso.
		[‚úÖ] No acepta argumentos entre comillas, hay que hacer clean_input.
-	 [‚úÖ] Expansi√≥n de variables de entorno.
-	 [‚úÖ] Gesti√≥n de $?.
2    [‚úÖ] Gesti√≥n de Ctrl-C, Ctrl-D y Ctrl-\, deben funcionar como bash.
	2.1	[‚úÖ] Ctrl-C (Imprime salto de linea), Ctrl-D (Termina SHELL) y Ctrl-\ (No hace nada).
	 [‚úÖ] Built-ins: echo (-n), cd (Rutas relativas/absolutas), pwd, export, unset, env y exit.
		[‚úÖ] Rutas absolutas (cd ~ funciona con /)
		[‚úÖ] Export revisarlo para sobreescribir variables (Planteamiento comentado en export.c)

üìí __________ NORMINETTE LIST __________ üìí

 üìÅ [‚ùì] src
	-	 [‚úÖ] minishell.c
	-	 [‚úÖ] update_minishell.c
	-	 [  ] exec.c
	-	 [  ] path_utils.c
	-	 [  ] path.c
	-	 [  ] signals.c
	-	 [  ] variable_expansion.c
	 üìÅ [‚ùì] parse
		-	 [‚ùì] input_utils.c (muchas funciones)

-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos
-	 [  ] archivos

‚úÖ ""
‚úÖ ''
‚úÖ echo $
‚úÖ exit 3456 -> deberia de salir con arg[1] % 256
‚úÖ exit hola -> deber√≠a de salirse con el codigo 2 al hacer echo $?
‚úÖ revisar funcionamiento de "wc < wc << pejjo"
‚úÖ ls || wc
‚úÖ wc < hola.txt < (redireccion abierta hay que manejarlo)
‚úÖ NO SE SI MANEJAR -> cd - , se va al pwd anterior, y si lo vuelves a usar vuelve al anterior
‚úÖ cd | exit -> NO deberia de salirse
‚úÖ"ls -> mensaje de quotes abiertas
‚úÖ export a=, deber√≠a de exportar a=""
‚úÖ export a, se duplica. Solo manejamos con =, pero sin = se acaba duplicando -> hemos hecho que si exporta "casa" se exporte como "casa=", valido?
‚úÖ export cuando haces por ej; HOME+=perro ser√≠a como concatenarle perro
‚úÖ export debe aceptar varias variables (si falla una, las demas se deben hacer)
‚úÖ wc << EOF1 | grep hola << EOF2 -> actualmente wc sale a pantalla en lugar de la pipe
‚úÖ export jojo y luego export jojo+=jiji, en declare_matrix se duplica, deber√≠a de existir solo jojo=jiji
‚úÖ LIMPIAR CD, hay que reformularlo m√°s legible y con m√°s sentido (variables, funciones, etc.)
‚úÖ cd -> cuando HOME no existe deberia dar "bash: cd: HOME not set"



üìù __________ GDB DEBUGGING GUIDE __________ üìù

FORK DEBUGGING:
- Start GDB: `gdb -tui ./minishell`
- Follow child process after fork: `set follow-fork-mode child`
- Set up before running: `set detach-on-fork off`
- Set initial breakpoints: `b ft_pipe` `b execute_cmd`
- Run program: `r`
- List all forked processes: `info inferiors`
- Switch between processes: `inferior num`
- Analyze pipes: `p minishell->pipe_tools.pipes[0]`
- Check FDs: `shell ls -l /proc/$(pid)/fd`
- Switch process: `inferior 2` (child process)

USEFUL VARIABLES TO WATCH:
- Process info: `p getpid()`
- Fork result: `p fork_pid`
- Pipe FDs: `p minishell->pipe_tools.pipes[0].read_pipe` `p minishell->pipe_tools.pipes[0].write_pipe`



Lista de excepciones con echo + redirecciones:

‚úÖ [1] EJEMPLO: echo >hola
- BASH: Crea el archivo "hola" y lo deja vac√≠o.
- MINISHELL: Crea el archivo "hola" y lo deja vac√≠o.

‚úÖ [2] EJEMPLO: echo ">hola"
- BASH: Imprime ">hola" en la salida est√°ndar.
- MINISHELL: No imprime nada.

‚úÖ [3] EJEMPLO: echo "hola >"
- BASH: Imprime "hola >" en la salida est√°ndar.
- MINISHELL: Imprime "hola >" en la salida est√°ndar.

‚úÖ [4] EJEMPLO: echo "hola >" > archivo
- BASH: Crea el archivo "archivo" y le introduce "hola >".
- MINISHELL: Crea el archivo "archivo" y le introduce "hola >".

‚úÖ [5] EJEMPLO: echo hola>
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

‚úÖ [6] EJEMPLO: echo |jeje
- BASH: bash: jeje: command not found
- MINISHELL: minishell: jeje: command not found

‚úÖ [7] EJEMPLO: echo "ho > la" | wc
- BASH: Devuelve 1 3 8, resultado de wc.
- MINISHELL: Devuelve 1 3 8, resultado de wc.

‚úÖ [8] EJEMPLO: echo hola < TODO.txt
- BASH: Imprime "hola" en la salida est√°ndar.
- MINISHELL: Imprime "hola" en la salida est√°ndar.

‚úÖ [9] EJEMPLO: echo hola << jeje
- BASH: Imprime "hola" en la salida est√°ndar.
- MINISHELL: Imprime "hola" en la salida est√°ndar.

‚úÖ [10] EJEMPLO: echo ">" (tambi√©n ">>", "<<" y "<")
- BASH: Imprime > en la salida est√°ndar.
- MINISHELL: Imprime ">" en la salida est√°ndar.

‚úÖ [11] EJEMPLO: echo "|"
- BASH: Imprime | en la salida est√°ndar.
- MINISHELL: Imprime | en la salida est√°ndar.

‚úÖ [12] EJEMPLO: echo <
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

‚úÖ [13] EJEMPLO: echo >
- BASH: bash: syntax error near unexpected token `newline'
- MINISHELL: minishell: syntax error near unexpected token `newline'

‚úÖ [14] EJEMPLO: echo |
- BASH: Abre un heredoc
- MINISHELL: minishell: syntax error cmd after pipe

/* ---------- TODO 22/05/2025 --------- */

‚úÖ 1.- Si se ejecuta minishell sin variables de entorno debe estar controlado -> if (!env || !*env)

‚úÖ 2.- Redir in debe redirigir el input independientemente de si est√° antes o despu√©s, si es el √∫ltimo debe hacerlo. Ejemplo: <archivo cat
‚úÖ| >
‚úÖ| <
‚úÖ| <<
‚úÖ| >>

‚úÖ3.- SHLVL debe aumentarse cuando ejecutas shell dentro de minishell
‚úÖ Hay que implementarlo, funci√≥n hecha con condici√≥n, ver el sitio

‚úÖ 4.- ""''"" da segfault, """", ''''

‚úÖ 5.- Si una carpeta se llama ls, al hacer ls ls, debe ejecutar el comando dentro de la carpeta, eso quiere decir que el comando tiene prioridad frente al archivo que est√© en la ruta actual.

 touch cat
 chmod 755 cat
 cat file
Esto no hace cat del file, hay que asegurarse de que si el cmd no contiene "/" busque en el PATH

‚úÖ 6.- cat saliendose con ctrl +c deberia de dar 130 en el echo $?

‚úÖ 7.- cd algo, unset OLDPWD, cd - -> nos da segfault, debe escribir un mensaje que sea minishell: cd: OLDPWD not set
‚úÖ ¬øSe vuelve a setear OLDPWD al cambiar de directorio? SI

‚úÖ 8.- Cuando hace exit sin arg, usa el ultimo codigo de salida. Con arg numerico el modulo del argumento de 256
‚ùì Chequear el resto de codigos de salida para ver si salen correctos

‚úÖ 9.- < Makefile cat < popo debe redireccionar el archivo popo a cat, e imprime su contenido

‚úÖ 10.- << popo cat << lala | cat << lala2 -> Deberia ser popo, lala y luego lala2, pero no funciona
‚ùì Probamos a hacerlo el 26/05 e iba bien, rarete

‚úÖ ejecutarlo con ./leaks, es para ver fds abiertos y still reachables
‚ùì Aparentemente el unico still reachable es la est√°tica de shell_prompt

‚úÖ Al cerrar pipes los inputs parecen haberse trastocado

REVISADO N√öMERO FUNCIONES POR ARCHIVOS Y NORMINETTE

PROBLEMA CON EL INCLUDE EN TODOS LOS ARCHIVOS

/*------built-in-----*/

‚úÖ ‚úÖ built (2)
‚úÖ ‚úÖft_cd (4) 
	‚úÖ ‚úÖcd_utils (5)
‚úÖ ‚úÖ echo (2)
‚úÖ ‚úÖ env (1)
‚úÖ ‚úÖ exit (3)
‚úÖ ‚úÖ export (2)
	‚úÖ ‚úÖexport_cases (5)
	‚úÖ ‚úÖexport_declare (3)
	‚úÖ export_utils (5)
‚úÖ ‚úÖ pwd (1)
‚úÖ ‚úÖ unset (4)

/*--------MAIN--------*/

‚úÖ ‚úÖ minishell_utils.c (3)
‚úÖ ‚úÖ update_minishell (4)

/*------PARSE--------*/

‚úÖ ‚úÖ input.c (3)
‚úÖ ‚úÖ input_utils (4)
‚úÖ ‚úÖ prompt.c (2)
‚úÖ ‚úÖ is_redirection.c (4)
‚úÖ ‚úÖ split.c (5) 
‚úÖ ‚úÖ split_utils (5)
‚úÖ ‚úÖ path_utils (3)
‚úÖ ‚úÖ path (2)
‚úÖ ‚úÖ QUOTE_UTILS (2)
‚úÖ ‚úÖ expand_var (5)
‚úÖ ‚úÖ expand_redir (4)

/*-------REDIRECTION_UTILS--------*/

‚úÖ ‚úÖ fork_redir (3)
‚úÖ ‚úÖ pipe_libft (1)
‚úÖ ‚úÖ pipe_utils (3)
‚úÖ ‚úÖ redir_cmd_cleaner (2)
‚úÖ ‚úÖ fd_utils (5)

/*---------REDIRECTIONS-------------*/

‚úÖ ‚úÖ redir_in (4)
‚úÖ ‚úÖ redir_out (2)
‚úÖ ‚úÖ redir_pipe (2)
‚úÖ ‚úÖ redirect (3)
‚úÖ ‚úÖ redirect_utils (3)

/*-----------VALIDATIONS------------*/

‚úÖ ‚úÖ valid_cmd (2)
‚úÖ ‚úÖ valid_env_char (1)
‚úÖ ‚úÖ valid_rl_input (2)
‚úÖ ‚úÖ valid_symbols (1)
‚úÖ ‚úÖ valid_redir (5)


‚úÖ exec (4)
‚úÖ signals (2)
----

-------- FERNANDO -------

HEREDOC -> no se puede salir con CTRL + C, en bash S√ç se sale

‚úÖ CMD cat, cuando hacemos CTRL + C se sale sin el salto de l√≠nea

‚úÖ Los syntax error deben dar el codigo de error correcto

-------- V√çCTOR -------

‚úÖ problema:	Cuando hay un error de sintaxis no se pone el codigo de salida
solucion:	Establecerlo en 2 o un valor diferente a 0
necesario:	No, pero no cuesta mucho hacerlo

‚úÖ problema:	Espacio muy grande en mensaje (ls >)
solucion:	Quitar el espacio. lol
necesario:	No

‚úÖ problema:	2 o mas tokens de redireccion juntos se tratan como input (< < cat o < < < cat)
solucion:	Si el input de una redireccion es un token de redireccion mostrar error de sintaxis
necesario:	No

BUILT-IN
--------

problema:	Cuando se esta en una carpeta invalida (borrada) deja de funcionar cd. (mkdir -p a/b/c), (cd a/b/c), (rm -rf ../../../a)
solucion:	No sabria decir, no me he puesto a ver el codigo, pero no es importante. Probablemente no estais ejecutando chdir
necesario:	No, son casos extremos. Aunque no creo que sea complicado de solucionar.
‚ùì Esto se controla haciendo un chdir al home predeterminado

SE√ëALES
-------

repo guay: https://github.dev/zafraedu/minishell/tree/main/src

OJO!!!		Creo que no teneis una variable global para las se√±ales. Es necesaria para poder saber si se ha producido un SIGINT y cancelar la ejecucion (heredoc, etc.)

‚úÖ problema:	CTRL + \ (SIGQUIT) no se ignora
‚úÖ solucion:	Establecer SIGQUIT en SIG_IGN y al ejecutar un hijo, establecerlo en SIG_DFL
necesario:	Si, especificado en el subject

‚úÖ problema:	CTRL + C no pone el last status a 130 (128 + signal)
solucion:	En algun momento comprobar si la variable de las se√±ales es diferente de 0 y asignar 128 mas esa variable a las status (suponiendo que la variable sea el valor de la se√±al)
necesario:	Quizas, aunque si el evaluador no es muy cerrado, lo puede dejar pasar

problema:	CTRL + C se ejecuta en los hijos (cat y CTRL + C) y sale doble prompt
necesario:	Quizas, aunque si el evaluador no es muy cerrado, lo puede dejar pasar

problema:	CTRL + C no funciona en heredoc (<< a cat y CTRL + C) y cuando hay varios juntos hace cosas mas extra√±as aun ( << a cat << b <<c | <<a cat y CTRL + C)
necesario:	Si, especificado en el subject

‚úÖ problema:	Espacio muy grande en mensaje en el heredoc al hacer CTRL + D (<< a cat y CTRL + D)
solucion:	Quitar el espacio. lol
necesario:	No

‚úÖ problema:	Linea extra al hacer CTRL + C despues de un CTRL + D en un heredoc
solucion:	No sabria decir donde, es por cosas de se√±ales
necesario:	No, eso le ha pasado a mas gente y dudo que un evaluador lo tenga en cuenta

‚úÖ problema:	Al salir con CTRL + D no se sale con el ultimo codigo de salido
solucion:	Cuando readline devuelve NULL dependiendo de como se salga, hacer return (last_code) o exit(last_code)
necesario:	Quizas, no se si se dice explicitamente, pero no deberia ser dificil de implementar

‚úÖ LEAKS
-----

‚úÖ Al parecer en los hijos hay 2 FD que se quedan abiertos (aparte de los standars)
Pueden ser backups de STDIN y STDOUT si los haceis en el padre, ya que el hijo los hereda o
puede que sean otros. Se crean en minishell_store_fd() al parecer

‚úÖ Luego "leaks" tambien hay algunos. No son leaks, pero para 42 todo lo que no se libere se considera leak...
Y en el padre tambien hay algo de leak

kobayashi ‚ûú /mnt/d/Programas/Mis Programas/42/Active/mini ‚ú¶ echo popo | echo popo

==81991== FILE DESCRIPTORS: 5 open (3 std) at exit.
==81991== Open file descriptor 4: /dev/pts/0
==81991==    at 0x49CB93B: dup (syscall-template.S:120)
==81991==    by 0x10DFF1: minishell_store_fd (fd_utils.c:43)
==81991==    by 0x10B13B: init_minishell (minishell_utils.c:18)
==81991==    by 0x10B5C0: main (minishell.c:31)
==81991==
==81991== Open file descriptor 3: /dev/pts/0
==81991==    at 0x49CB93B: dup (syscall-template.S:120)
==81991==    by 0x10DFE0: minishell_store_fd (fd_utils.c:42)
==81991==    by 0x10B13B: init_minishell (minishell_utils.c:18)
==81991==    by 0x10B5C0: main (minishell.c:31)
==81991==
==81991==



cat << eof

*eof -> ‚úÖ
*SIGINT -> ‚úÖ


cat << eof | ls

*eof -> ‚úÖ
*SIGINT -> ‚úÖ

ls | cat << eof

*eof -> ‚úÖ Se queda abierta la 5
*SIGINT -> ‚úÖ


cat << eof | ls | cat << eof2 (SALIR SIN CONTROL + C, HACERLO DE MANERA TRADICIONAL)

*eof, eof2 -> ‚úÖ Se queda abierta la n√∫mero 5
*eof, SIGINT -> ‚úÖ Se queda abierta la n√∫mero 5
*SIGINT -> ‚úÖ

ls | cat << eof | ls | cat << eof2

*eof, eof2 ‚úÖ
*eof, SIGINT ‚úÖ
*SIGINT -> ‚ùì Se queda abierto el 5

----

PARA EVITAR EL ERROR DEL CLOSE STDIN EN COMANDOS QUE LEEN DE STDIN, REESTABLECER
USANDO LAS COPIAS DE STDIN QUE TENEMOS, LA IDEA ES QUE USEMOS CLOSE STDIN PARA
TERMINAR EL READLINE, Y DESPUES REESTABLECER UN STDIN ESTANDAR

(TAMBIEN PUEDE QUE SIMPLEMENTE ROMPAMOS ANTES DE EJECUTAR EXECVE)